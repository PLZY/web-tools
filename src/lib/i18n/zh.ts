export const zh = {
  // Navbar & Common
  'nav.home': '首页',
  'nav.maven': 'Maven 依赖',
  'nav.logback': 'Log 配置',
  'nav.cron': 'Cron 翻译',
  'nav.sql': 'SQL 转 Java',
  'nav.jvm': 'JVM 调优',
  'common.clear': '清空',
  'common.parse': '解析',
  'common.example': '加载示例',
  'common.search': '搜索...',
  'common.copy': '复制',
  'common.back': '返回',
  'common.copied': '复制成功',
  'common.clearSearch': '清空搜索',
  'common.others': '其他',
  'common.versions': '个版本',
  'common.unknown': '未知',

  // Home Page
  'home.title': '狗狗蹦跶工具站',
  'home.seo.title': '狗狗蹦跶工具站 | DogUp DevTools - 开发者工具箱',
  'home.seo.description': '提供 Maven 依赖排查、Logback 配置生成、Cron 表达式解析、SQL 转 Java POJO、JVM 参数调优等极客工具，助力 Java 开发者提升效率。',
  'home.seo.keywords': 'Java工具, Logback配置, Maven依赖分析, Cron表达式, SQL转Java, JVM调优, DogUp',
  'home.subtitle': '“Maven 依赖树可视化，Cron 表达式解析器。让复杂的开发配置一眼看清。”',
  'home.maven.title': 'Maven 依赖排查',
  'home.maven.desc': '依赖关系可视化分析。支持全路径解析与版本冲突高亮，提供便捷的依赖树检索与排查体验。',
  'home.logback.title': 'Logback 配置',
  'home.logback.desc': '交互式表单生成 XML 配置，告别手动编写 XML 的痛苦。',
  'home.cron.title': 'Cron 翻译官',
  'home.cron.desc': '定时任务执行时序分析。支持 Spring、Quartz、xxl-job 等多种常用 Cron 表达式规范。',
  'home.sql.title': 'SQL 转 Java',
  'home.sql.desc': 'DDL 一键生成 POJO。支持常用注解预设，快速构建符合标准的 Java 实体类。',
  'home.jvm.title': 'JVM 模板',
  'home.jvm.desc': '启动参数最佳实践。内置不同内存环境下的配置模板，直接复制，快速启动。',
  'home.core': '核心',
  'home.privacy.title': '数据安全性如何？',
  'home.privacy.desc': '“数据安全是我们的首要原则。本站所有解析逻辑均在客户端浏览器本地执行，您的源码、依赖文本或 DDL 数据不会上传至服务器。”',
  'home.intent.title': '为什么创建这个站点？',
  'home.intent.desc': '“在日常开发中，我们经常需要处理复杂的 Maven 依赖冲突或调试多样的 Cron 表达式时序。建立这个站点是为了提供一个更直观、跨平台的在线辅助方案，方便大家快速定位问题。”',
  'home.seo.text': 'DogUp DevTools 是一个专为 Java 开发者设计的在线工具集。在微服务和云原生架构中，Maven 依赖管理和 JVM 调优是提升系统稳定性的关键。我们的工具支持标准 mvn dependency:tree 解析，帮助开发者快速解决 Jar 包冲突。同时，通过 DDL 转 Java 实体类工具，可以大幅减少重复的建模工作。所有工具均遵循极简设计原则，致力于提升开发者的日常生产力。',
  'home.notes.title': '开发者寄语',

  // Maven Tool
  'maven.title': 'Maven 依赖排查器 (Dependency Analyzer)',
  'maven.desc': '可视化分析 mvn dependency:tree 输出，快速定位 Jar 包冲突与循环依赖。',
  'maven.input.title': '输入 Maven Output',
  'maven.input.placeholder': "请粘贴 'mvn dependency:tree' 的完整输出...",
  'maven.graph.search': '搜索节点...',
  'maven.graph.clearPath': '清除路径追溯',
  'maven.graph.tips': '提示：支持缩放、平移及点击节点追溯路径',
  'maven.tab.list': '列表视图 (List)',
  'maven.tab.conflict': '冲突雷达',
  'maven.tab.weight': '依赖权重',
  'maven.stat.conflict': '冲突',
  'maven.stat.managed': '托管',
  'maven.stat.duplicate': '重复',
  'maven.list.detail': '依赖树明细',
  'maven.list.expandConflict': '快速定位冲突',
  'maven.list.collapseAll': '显示全部路径',
  'maven.list.locateConflict': '定位冲突',
  'maven.list.showAll': '显示全部',
  'maven.list.matchResult': '匹配到 {n} 个结果',
  'maven.conflict.title': '版本冲突深度分析',
  'maven.conflict.chart.title': '组件冲突数量 (Top 10)',
  'maven.conflict.chart.xAxis': '版本数量',
  'maven.conflict.card.winner': '已采用 (Winner)',
  'maven.conflict.card.omitted': '被屏蔽的版本 (Omitted)',
  'maven.conflict.card.from': '来自',
  'maven.conflict.versions': '{n} 个版本冲突',
  'maven.weight.title': '依赖结构权重分布',
  'maven.weight.chart.group': '组织分布 (Top 8 + Others)',
  'maven.weight.chart.scope': '依赖作用域分布',
  'maven.node.conflict': '冲突',
  'maven.node.managed': '版本托管',
  'maven.node.duplicate': '重复',
  'maven.help.title': '为什么需要分析 Maven 依赖树？',
  'maven.help.content': '在 Java 项目开发中，"Jar Hell"（Jar 包地狱）是一个经典问题。当项目依赖复杂时，不同库可能会传递依赖同一个 Jar 包的不同版本，导致运行时出现 NoSuchMethodError 或 ClassNotFoundException。',
  'maven.how.title': '如何生成依赖树？',
  'maven.how.content': '要使用本工具，您首先需要在项目根目录下运行以下 Maven 命令：\n\nmvn dependency:tree\n或者，如果您想查看详细的冲突信息（包含被屏蔽的旧版本），可以使用：\n\nmvn dependency:tree -Dverbose',
  'maven.mechanism.title': 'Maven 的依赖仲裁机制',
  'maven.mechanism.desc': 'Maven 处理依赖冲突主要遵循两个原则：',
  'maven.mechanism.nearest.title': '路径最近者优先',
  'maven.mechanism.nearest.desc': '如果依赖路径深度不同，Maven 会选择路径最短的那个版本。',
  'maven.mechanism.first.title': '第一声明者优先',
  'maven.mechanism.first.desc': '如果依赖路径深度相同，Maven 会选择在 pom.xml 中最先声明的那个版本。',
  'maven.resolve.title': '如何解决依赖冲突？',
  'maven.resolve.desc': '一旦通过本工具定位到冲突，您可以通过以下方式解决：',
  'maven.resolve.exclusion': '排除依赖 (Exclusion)',
  'maven.resolve.mgmt': '锁定版本 (Dependency Management)',

  // JVM Tool
  'jvm.title': 'JVM 调优配方 (JVM Tuning Recipe)',
  'jvm.desc': '输入您的服务器配置与应用类型，获取经过生产环境验证的“极致” JVM 启动参数。',
  'jvm.help.title': '为什么需要 JVM 调优？',
  'jvm.help.content': 'Java 虚拟机 (JVM) 的默认参数通常偏向保守，无法充分利用现代服务器的大内存与多核优势。不合理的配置会导致频繁的 Full GC、应用停顿 (STW) 甚至 OOM 崩溃。本工具基于 Oracle 官方文档与业界最佳实践，为您生成即插即用的启动命令。',
  'jvm.config.server': '服务器配置',
  'jvm.config.mem': '可用内存',
  'jvm.config.cpu': 'CPU 核心数',
  'jvm.config.type': '应用类型',
  'jvm.type.web': '标准 Web 应用 (低延迟优先)',
  'jvm.type.batch': '后台批处理 (高吞吐优先)',
  'jvm.type.micro': '微服务节点 (节省资源)',
  'jvm.result.title': '推荐启动参数',
  'jvm.result.copy': '复制参数',
  'jvm.analysis.title': '参数深度解析',
  'jvm.feature.title': '核心调优维度',
  'jvm.feature.memory': '内存分配',
  'jvm.feature.gc': 'GC 策略',
  'jvm.feature.metaspace': '元空间',

  // Logback Tool
  'logback.title': 'Logback / Log4j2 配置生成',
  'logback.desc': '生成生产环境就绪的 Logback / Log4j2 配置文件，内置最佳实践。',
  'logback.help.title': '日志配置最佳实践',
  'logback.help.content': '在生产环境中，合理的日志配置对于排查问题和监控系统健康状况至关重要。DogUpUp 提供的生成器遵循以下最佳实践：异步日志 (Async Appender)、滚动策略 (Rolling Policy)、以及格式化与高亮。',
  'logback.config.basic': '基础设置',
  'logback.config.framework': '日志框架',
  'logback.config.appName': '应用名称 (APP_NAME)',
  'logback.config.logPath': '日志路径 (LOG_PATH)',
  'logback.config.logbackDesc': 'Logback (Spring Boot 默认)',
  'logback.config.level': '全局日志级别',
  'logback.config.packageLevel': '特定包日志级别 (Logger)',
  'logback.config.maxFileSize': '单文件最大大小',
  'logback.config.totalCap': '总大小上限 (Total Cap)',
  'logback.config.async': '启用异步日志 (AsyncAppender) - 推荐生产环境开启',
  'logback.feature.title': '关键特性',
  'logback.feature.async': '异步日志',
  'logback.feature.rolling': '滚动策略',
  'logback.feature.color': '彩色控制台',
  'logback.result.title': '生成的 XML 配置',
  'logback.preview.title': '配置文件预览',
  'logback.xml.appName': '应用名称',
  'logback.xml.logPath': '日志文件保存路径',
  'logback.xml.maxHistory': '日志保留天数',
  'logback.xml.maxFileSize': '单个文件最大大小',
  'logback.xml.totalCap': '总文件大小上限',
  'logback.xml.consolePattern': '彩色日志格式',
  'logback.xml.filePattern': '文件日志格式',
  'logback.xml.consoleAppender': '控制台输出',
  'logback.xml.fileAppender': '文件输出 (滚动)',
  'logback.xml.rollingFormat': '滚动文件名格式',
  'logback.xml.asyncAppender': '异步输出',
  'logback.xml.asyncDesc1': '不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志',
  'logback.xml.asyncDesc2': '更改默认的队列的深度,该值会影响性能.默认值为256',
  'logback.xml.asyncDesc3': '添加附加的appender,最多只能添加一个',
  'logback.xml.packageLevel': '特定包日志级别',
  'logback.xml.rootLevel': '根日志级别',
  'logback.xml.monitorInterval': '自动检测配置修改的时间间隔(秒)',
  'logback.xml.properties': '属性配置',
  'logback.xml.appenders': '输出目的地配置',
  'logback.xml.loggers': '日志记录器配置',

  // Cron Tool
  'cron.title': 'Cron 翻译官 (Cron Translator)',
  'cron.desc': '输入 Cron 表达式，立即获取人类可读的中文解释，并预测未来 7 次执行时间。',
  'cron.help.title': 'Cron 表达式语法速查表',
  'cron.input.placeholder': '输入 Cron 表达式 (如: 0 0/5 * * * ?)',
  'cron.desc.title': '执行逻辑说明',
  'cron.timeline.title': '未来 7 次执行时间轴',
  'cron.table.title': '标准字段含义',
  'cron.table.pos': '位置',
  'cron.table.field': '字段',
  'cron.table.values': '允许值',

  // SQL Tool
  'sql.title': 'SQL 转 Java POJO 生成器',
  'sql.desc': '粘贴 SQL 建表语句 (DDL)，一键生成带有 Lombok、JPA 和 Swagger 注解的 Java 实体类。',
  'sql.help.title': '为什么需要 SQL 转 Java POJO 工具？',
  'sql.help.content': '在 Java 后端开发中，编写实体类（Entity/POJO）是一项重复且繁琐的工作。本工具旨在解析标准的 SQL DDL 语句，自动提取表名、字段名、字段类型、注释等信息。',
  'sql.input.placeholder': '输入 CREATE TABLE DDL 语句...',
  'sql.config.lombok': '使用 Lombok',
  'sql.config.swagger': '包含 Swagger 注解',
  'sql.result.title': '生成的 Java 代码',
  'sql.config.package': '包名',
  'sql.config.author': '作者',
  'sql.config.jpa': '使用 JPA 注解',
  'sql.config.validation': '使用 Jakarta 校验',
  'sql.result.regen': '重新生成',
  'sql.feature.title': '核心特性',
  'sql.feature.multiDb': '多数据库支持：兼容 MySQL 和 PostgreSQL 语法。',
  'sql.feature.mapping': '智能类型映射：自动将 SQL 类型映射为 Java 类型。',
  'sql.feature.lombok': 'Lombok 集成：告别样板代码。',
  'sql.table.title': 'SQL 类型映射表',
  'og.slogan': 'DogUp - 开发者工具箱',
  'maven.input.error': '请输入 Maven 依赖树文本',
  'maven.parse.error': '未能解析出有效的依赖树结构，请检查输入格式是否为 \'mvn dependency:tree\' 的输出',
  'maven.parse.fail': '解析出错，请检查输入格式',
  'maven.node.subtree_matches': '内含 {n} 个匹配',
  'maven.node.contains_conflict': '内含冲突'
};
